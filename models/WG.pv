(* ===== DATA TYPES ===== *)

type Id_t.        
type Nonce_t.     (* Nonce *)
type e_t.         (* DH exponent *)
type G_t.         (* DH group *)
type K_t.         (* Key *)
type MAC_t.       (* MAC *)
type Sig_t.       (* Signature *)
type Cert_t.      (* Certificate *)
type Tag_t.       (* Message type tag *)
type IP_t.        (* IP address of peer *)

(* ===== CHANNELS ===== *)

(* Public channel *)
free c:channel.

(* ===== TABLES ===== *)
table trusted_responders(IP_t, e_t, G_t).
table trusted_initiators(IP_t, e_t, G_t).

(* ===== CONSTANTS ===== *)

(* CA secret key *)
const SK_CA:K_t [private].

(* DH generator *)
const G:G_t.

(* Wireguard constants *)
const CONSTRUCTION:bitstring.
const IDENTIFIER:bitstring.
const LABEL_MAC1:bitstring.
const EMPTY_KEY:K_t.
const ONE,TWO:bitstring.
const EMPTY_DH:G_t.
const EMPTY_TXT:bitstring.

(* ===== FUNCTIONS ===== *)

(* Generate a public key from a private key *)
fun pk(K_t): K_t.


(* Sign a certificate with a private key *)
fun signcert(Id_t,K_t,K_t): Cert_t.

reduc forall id:Id_t,Pk:K_t,Sk:K_t;
  checkcert(signcert(id,Pk,Sk),pk(Sk)) = (id,Pk)
.

(* Create a certificate *)
letfun certificate(id:Id_t,Pk:K_t) =
  signcert(id,Pk,SK_CA)
.

(* Sign a bitstring with a private key *)
fun sign(bitstring,K_t): Sig_t.
reduc forall bs:bitstring, Sk:K_t;
  checksign(sign(bs,Sk),pk(Sk)) = bs
.

(* Symmetric encryption/decryption *)
fun enc(bitstring,K_t): bitstring.
reduc forall k:K_t, m:bitstring;
  dec(enc(m,k),k) = m
.

(* Diffie-Hellman key exchange *)
fun DH(e_t,G_t): G_t.
equation forall x:e_t, y:e_t;
  DH(y,DH(x,G)) = DH(x,DH(y,G))
.

(* MAC *)
fun MAC(bitstring,bitstring): MAC_t.

(* Hash *)
fun hash(bitstring): bitstring.

(* KDF *)
fun KDF(G_t,bitstring): K_t.
fun KDFhelp(K_t,bitstring): K_t.
fun KDF1(bitstring, G_t): bitstring.
letfun KDF2(c:bitstring, dh:G_t) = 	   
       let c' = hash((c, dh)) in
       let k = KDF(dh,c) in
       (c',k).
letfun KDF3(c:bitstring, q:K_t) = 	   
       let c' = hash((c, q)) in
       let t = hash((c', ONE)) in
       let k = KDFhelp(q,(t, TWO)) in
       (c',t,k).


fun toG(bitstring): G_t [typeConverter].
fun toBS(G_t): bitstring [typeConverter].

(* ===== EVENTS ===== *)

event AcceptKeyInitiator(IP_t, IP_t, K_t).
event AcceptKeyResponder(IP_t, IP_t, K_t).
event SendPayloadResponder(IP_t, IP_t, K_t).
event AcceptPayloadInitiator(IP_t, IP_t, K_t).


(* ===== QUERIES ===== *)

query ipr,ipi:IP_t, k:K_t; event(AcceptKeyInitiator(ipr, ipi, k)) ==> event(AcceptKeyResponder(ipr, ipi, k)). 
query ipr,ipi:IP_t, k:K_t; event(AcceptPayloadInitiator(ipr, ipi, k)) ==> event(SendPayloadResponder(ipr, ipi, k)). 

(* Reachability *)
query ipr,ipi:IP_t,k:K_t; event(AcceptPayloadInitiator(ipr, ipi, k)).

(* ===== PROCESSES ===== *)

let initiator(ipi:IP_t, si_priv:e_t, si_pub:G_t, ipr:IP_t, sr_pub:G_t) =

    (* Send message 1 *)
    let ci1 = hash(CONSTRUCTION) in
    let hi1 = hash((ci1, IDENTIFIER)) in
    let hi2 = hash((hi1, sr_pub)) in
    new ei_priv:e_t;
    let ei_pub =  DH(ei_priv, G) in 
    out(c, ei_pub);
    let ci2 = KDF1(ci1,ei_pub) in 
    let hi3 = hash((hi2, ei_pub)) in
    let (ci3:bitstring, k1:K_t) = KDF2(ci2, DH(ei_priv, sr_pub)) in
    let static = enc((si_pub, hi3), k1) in
    let hi4 = hash((hi3, static)) in
    let (ci4:bitstring, k2:K_t) = KDF2(ci3, DH(si_priv, sr_pub)) in
    new ts:Nonce_t;
    let timestamp = enc((ts, hi4), k2) in
    let hi5 = hash((hi4, timestamp)) in
    new ii:Nonce_t;
    let msg1 = (ii, ei_pub, static, timestamp) in 
    let mac1 = MAC(hash((LABEL_MAC1,sr_pub)), msg1) in
    out(c, (msg1, mac1));

    (* Receive message 2 *)
    in(c, (msg2:bitstring, msg2_mac1:MAC_t));
    if msg2_mac1 = MAC(hash((LABEL_MAC1,si_pub)), msg2) then
    let (ir:Nonce_t, =ii, er_pub:G_t, empty:bitstring) = msg2 in
    let ci5 = KDF1(ci4, er_pub) in 
    let hi6 = hash((hi5, er_pub)) in
    let ci6 = KDF1(ci5, DH(ei_priv, er_pub)) in
    let ci7 = KDF1(ci6, DH(si_priv, er_pub)) in
    let (ci8:bitstring, t:bitstring, k3:K_t) = KDF3(ci7, EMPTY_KEY) in
    let hi7 = hash((hi6, t)) in
    if hi7 = dec(empty, k3) then
    event AcceptKeyInitiator(ipr, ipi, k3);
    let (ti_send:bitstring, ti_recv:K_t) = KDF2(ci8, EMPTY_DH) in
    in(c, payload:bitstring);
    let(=ipr,=EMPTY_TXT) = dec(payload,ti_recv) in
    event AcceptPayloadInitiator(ipr, ipi, ti_recv);
    0.

let responder(ipr:IP_t, sr_priv:e_t, sr_pub:G_t, ipi:IP_t, si_pub:G_t) = 

    (* Receive message 1 *)
    in (c, (msg1:bitstring, mac1:MAC_t));
    if mac1 = MAC(hash((LABEL_MAC1,sr_pub)), msg1) then
    let(ii:Nonce_t, ei_pub:G_t, static:bitstring, timestamp:bitstring) = msg1 in 
    (* Compute encryption key *)
    let cr1 = hash(CONSTRUCTION) in
    let hr1 = hash((cr1, IDENTIFIER)) in
    let hr2 = hash((hr1, sr_pub)) in
    let cr2 = KDF1(cr1, ei_pub) in 
    let hr3 = hash((hr2, ei_pub)) in
    let (cr3:bitstring, k1:K_t) = KDF2(cr2, DH(sr_priv, ei_pub)) in
    let (=si_pub, =hr3) = dec(static, k1) in 
    (* Validate timestamp *)
    let hr4 = hash((hr3, static)) in
    let (cr4:bitstring, k2:K_t) = KDF2(cr3, DH(sr_priv, si_pub)) in
    let (ts:Nonce_t, =hr4) = dec(timestamp, k2) in
    let hr5 = hash((hr4, timestamp)) in

    (* Send message 2 *)
    new ir:Nonce_t;
    new er_priv:e_t;
    let er_pub = DH(er_priv, G) in
    out(c, er_pub);
    let cr5 = KDF1(cr4, er_pub) in 
    let hr6 = hash((hr5, er_pub)) in
    let cr6 = KDF1(cr5, DH(er_priv, ei_pub)) in
    let cr7 = KDF1(cr6, DH(er_priv, si_pub)) in
    let (cr8:bitstring, t:bitstring, k3:K_t) = KDF3(cr7, EMPTY_KEY) in
    let hr7 = hash((hr6, t)) in 
    let empty = enc(hr7, k3) in
    let msg2 = (ir, ii, er_pub, empty) in
    let msg2_mac1 = MAC(hash((LABEL_MAC1,si_pub)), msg2) in
    event AcceptKeyResponder(ipr, ipi, k3);
    out(c, (msg2, msg2_mac1));
    let (tr_recv:bitstring, tr_send:K_t) = KDF2(cr8, EMPTY_DH) in
    event SendPayloadResponder(ipr, ipi, tr_send);
    out(c, enc((ipr,EMPTY_TXT),tr_send));
    0.

process 

    !(  
        new ipi:IP_t; 
        new si_priv:e_t; let si_pub = DH(si_priv, G) in out(c, si_pub);
        new ipr1:IP_t; new ipr2:IP_t; 
        new sr_priv: e_t; let sr_pub = DH(sr_priv, G) in out(c, sr_pub);
        !initiator(ipi, si_priv, si_pub, ipr1, sr_pub) | !responder(ipr1, sr_priv, sr_pub, ipi, si_pub) | !responder(ipr2, sr_priv, sr_pub, ipi, si_pub) 
     )

